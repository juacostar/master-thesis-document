\chapter{Identification of Architectural Erosion Issues at Commit Level}
\label{cha:identification}

We can extend the solution approaches of AER issues identification in software projects based on static code analysis techniques. In this case, we implemented an analysis over a set of GitHub commits extracted from different Android projects. With the set of commits, we can identify different code fragments and implementations that could affect the architecture quality of any Android project. To get a better performance in AER issues identification, we used a set of keywords from used Word Embedding models and implemented some NLP techniques to identify the most related keywords in the commit messages. After that, we identified possible architectural smells and issues with a manual tagging process. Once the manual tagging was executed, we identified those issues and implemented a set of lint rules with the use of Android lint libraries to identify them inside any Android project. We tested that plugin and those rules with some applications to detect bad implementations in terms of architecture and quality attributes of any Android project.
The recent research about architectural erosion identification followed the same process of detection of potential issues in natural language in the commit messages from different version platforms. Furthermore, the study used different NLP techniques, like the use of static word embedding and word similarity metrics, for identifying potential words that have considerable semantic meaning in the development history of any application. With this base process, a list of potential keywords that could indicate an implemented bad architectural issue is created. However, the detection and selection process of different keywords was developed with large software Backend and Frontend projects. Those projects were implemented with traditional programming languages like Python and JavaScript. Those programming languages' documentation and support are greater than those of languages oriented toward mobile development. For this reason, it is necessary to adapt that identification methodology for the identification of potential words that have a semantic meaning inside commit messages inserted in a versioning platform for Android applications based on their source code. For this purpose, we extracted from 50 open-source Android applications and applied scraping techniques for GitHub history commit extraction. We can collect the committed messages and find similarities with the defined keywords in the research mentioned. A new version of the list of keywords will increase the accuracy of future selection and detection processes for Architectural erosion issues in the source code of Android applications.


\section{Methodology}
To address the research questions, we establish a methodology to design, implement, and evaluate a solution based on static code analysis, following the approaches described in the related work. Using a collection of commits extracted from multiple open-source Android projects, we apply NLP techniques supported by a static Word Embedding model. We then define a similarity metric to identify potential domain-specific keywords within the Android development context and conduct evaluation steps to assess the accuracy and relevance of the embedding model. Next, we analyze a representative subset of GitHub commits to detect recurring patterns and identify architectural smells. Once these smells are identified, the extracted patterns and rules are integrated into an Android Studio linter and validated through practical scenarios using real Android applications as well as a reference sample project. Finally, the proposed linter is evaluated by comparing its performance against other lint tools available in the Android Studio IDE.

\begin{figure}[h]
    	\centering
    		\includegraphics[scale=0.8]{./figures/workflow-1.png}
   			 \caption{Workflow for AER issues identification with Static Code Analysis techniques}
   			 \label{fig:ast}
\end{figure}


We will explain each stage of this workflow and show the results of this research compared with other proposed lint tools.

\subsection{Selection of sample Android apps}
Following the methodology described in the referenced research, we designed a similar extraction and selection process for the initial phase of commit analysis. First, we explored different alternatives and platforms to search and select open-source Android projects whose source code is hosted on GitHub. For this stage, we employed two tools. The first was SeART, a platform developed for data mining research on software repositories \cite{seart_platform}. This tool provides multiple filtering options that enable customized searches among open-source GitHub projects. In our case, we configured the filter to retrieve repositories whose primary programming language is Kotlin and whose commit history ranges between 1,000 and 30,000 commits. This configuration allowed the collection of a substantial number of commits to build a robust dataset capable of identifying meaningful keyword similarities using similarity metrics. Using this filter, we selected repositories with the largest commit histories. However, data mining techniques alone are not sufficient to exhaustively cover the diversity of GitHub repositories. Therefore, it was necessary to complement the search process with additional tools. To broaden the number of Android applications and improve the performance of AER identification, we incorporated a second tool focused specifically on Android software discovery: F-Droid. F-Droid is an open-source platform that catalogs open-source Android applications and provides relevant metadata, including the GitHub repository URL and information regarding application licensing. Using this information, we expanded the set of repositories considered for the study. After selecting the applications, we developed a program using web scraping techniques and the PyDriller library to extract and compile a dataset containing key information from each commit belonging to the GitHub repositories of the analyzed Android projects.


\begin{figure}[h]
    	\centering
    		\includegraphics[scale=0.3]{./figures/seART.png}
   			 \caption{seART platform for GitHub repositories searching \cite{seart_platform} }
   			 \label{fig:ast}
\end{figure}

\subsection{Word Embedding and Similarity Criteria}
With the collected set of commits from the mentioned Android apps collection, we made a preprocessing process for the developers' messages of those commits. In this case, we implemented a preprocessing flow with stemming, lemmatizing, and stop word removal. After that, we used the static pre-trained Word Embedding model, trained on 2 million Stack Overflow posts. With that model, we extracted the numerical representation of each word in the vocabulary of the GitHub commits dataset of selected Android applications. With the cosine similarity metric, we extracted the most similar words based on the keywords found in the related work.


\subsection{Architectural erosion symptoms Identification}
According to the findings of the referenced research, the identification of architectural erosion insights involves a detailed examination of information derived from developers’ judgments. These judgments can be obtained from various software version control systems, such as OpenStack, a platform used for large-scale software projects, or GitHub, the most widely adopted versioning platform. Using the information in commit messages, it is possible to classify and label code modifications by analyzing differences introduced over time. In this process, several Natural Language Processing (NLP) techniques are applied to derive a consistent definition of an architectural erosion–related commit. A key contribution of prior work is the use of pre-trained Word Embeddings in software development contexts to detect terms that may indicate architectural violations in server-side applications. By applying embedding models and similarity metrics such as Cosine Similarity, it becomes feasible to measure how closely related two words are based on their numerical embedding representations, reflecting their semantic behavior. These methods allow the standardization of common architectural erosion cases, the identification of metrics relevant to software projects, and the exploration of potential solution strategies. With the application of these NLP techniques, it is also possible to design discriminative models for detecting issues. However, in the Android domain, the study of architectural erosion has not yet led to a standardized set of detection rules in source code, largely due to the focus of previous research projects on Backend and Frontend systems—mainly implemented in Python. From the set of studies included in the initial review, a collection of keywords was identified from developer commit messages that could indicate potential architectural erosion issues. This prior study was performed based on developer evaluations and commit histories extracted from version control systems such as OpenStack and GitHub. The research analyzed four large open-source server-side applications and identified approximately fifty keywords as potential indicators of architectural erosion. Nevertheless, these keywords were obtained from Backend development contexts. Therefore, we adopted the same keyword extraction methodology but applied it to mobile development. For this purpose, we analyzed 50 open-source Android applications and collected approximately 470,000 GitHub commits. This dataset provided sufficient information to preprocess the vocabulary from the commit messages and derive new rules suitable for custom lint detection in mobile development environments. The definition and implementation of these rules will be discussed in the next chapter.


\subsubsection{Extracting keywords from Android Context}
To get a large set of commits to analyze, we found some platforms with open-source Android projects to extract their code and analyze their commits. We used different platforms based on the
Based on the last-mentioned research, it is possible to find potential keywords that indicate an issue or an insight inside a code implementation, with the help of NLP techniques, through similarity measurements like cosine similarity (mentioned in the definitions chapter) and pre-trained Word Embeddings, due to the numerical representation of each word of the generated vocabulary in a specific context. First, we use the PyDriller library \cite{pydriller}, a useful library for repository mining, for getting the code source and its attributes of different open-source Android projects made in Kotlin. The selected projects were extracted from different open-source Android project catalogs like F-Droid and other data mining repositories found with different filters like development programming language used, number of commits, and keywords in the selection criteria \cite{fdroid,repository_mining}. In the first overview, we extracted 50 Android projects that have around 470K commits. With these commits, we made a text pre-processing to build a standard vocabulary and tokenize with the help of the NLTK library \cite{nltk}, a library for making NLP operations like tokenization, lemmatization, and stemming.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|}
        \hline
        Keyword \\
        \hline
         architecture, architectural, structure, structural, \\
         layer, design, violate, violation, deviate, deviation,\\
         inconsistency, inconsistent, consistent, mismatch, diverge,\\
         divergence, divergent, deviate, deviation, architecture,\\
         layering, layered, designed, violates, violating, violated,\\
         diverges, designing, diverged, diverging, deviates, deviated, \\
         deviating, inconsistencies, non-consistent, discrepancy, deviations, \\
         modular, module, modularity, encapsulation, encapsulate, \\
         encapsulating, encapsulated, intend, intends, intended, \\
         intent, intents, implemented, implement, implementation,\\
         as-planned, as-implemented, blueprint, blueprints, mismatch,\\
         mismatched, mismatches, mismatching\\
         \hline
    \end{tabular}
    \caption{List of initial Keywords extracted of the mentioned related work}
    \label{tab:my_label}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Column & Description \\
        \hline
        Name Repo & Name of the GitHub repository of Android project source code \\
        \hline
        Url Repo & GitHub URL from source code repository \\
        \hline
       Commit Message & Message of a specific commit in GitHub commits history of each Android project \\
       \hline
       Commit Hash & Hash from GitHub commit, essential for the commits analysis process \\
       \hline
       File Name & List of GitHub commit modified file names \\
       \hline
       Code Changes & String with the modified source code of each GitHub commit \\
       \hline
    \end{tabular}
    \caption{Features of commits dataset and their description}
    \label{tab:my_label}
\end{table}

Using the complete commit corpus extracted from GitHub, we applied a text preprocessing pipeline that included stop-word removal and stemming. Lemmatization was not adopted because, in technical contexts, many terms do not have a valid lemma form, which may prevent the tokenizer from retaining relevant vocabulary. Stemming, by contrast, provides better control over lexical normalization for technical terms and ensures that semantically related word variants are mapped to a common root. This step is crucial, as many terms within commit messages do not contribute meaningful semantic information and could negatively influence similarity calculations. After preprocessing, we employed a pre-trained Word Embedding model built from millions of Stack Overflow posts. Using the Gensim library \cite{gensim}, we loaded the embedding model, generated numerical vector representations for each selected token, and calculated cosine similarity scores to retrieve semantically related terms for the known architectural erosion keyword set. For each reference keyword, we selected the ten most similar terms based on this metric. In the initial implementation, this approach allowed us to identify approximately 5,000 relevant commits using the expanded keyword list. To refine the selection in a more efficient way, we generated a representative subset by applying a weighted frequency analysis of token distribution across the corpus. Using this method, we obtained a final representative set of 357 GitHub commits for further analysis.


\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
    \hline
       Word  & Cosine Similarity Average Value \\
       \hline
        \texttt{notion} & 0.2674 \\
        \hline
        \texttt{respect} & 0.2627 \\
        \hline
        \texttt{formal} & 0.2482 \\
        \hline
        \texttt{high-level} & 0.2437 \\
        \hline
        \texttt{tend} & 0.2342 \\
        \hline
        \texttt{rigid} & 0.2315 \\
        \hline
        \texttt{kind} & 0.2256 \\
        \hline
        \texttt{stronger} & 0.2243 \\
        \hline
        \texttt{non-linear} & 0.2227 \\
        \hline
        \texttt{sane} & 0.2198 \\
        \hline
    \end{tabular}
    \caption{Top 10 newfound words since Word Embedding cosine similarity metric}
    \label{tab:my_label}
\end{table}

With this approach, it is possible to find potential words written in a development context that could indicate a potential issue related to different kinds of functional and non-functional requirements that a software project includes in its architectural design and its standards. This detection approach has many different development areas to detect different problems found in a software project. The future work related to this approach will be discussed in the next chapters.
\endinput