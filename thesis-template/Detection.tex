\chapter{Identifying AER With Static Code Analysis techniques}
\label{cha:detection}

With a set of possible causes presented in Kotlin source code files from various Android projects, it is possible to define a set of rules using the Android Studio IDE tools ecosystem for detecting Architectural Erosion issues. We detected architectural changes in the representative set of commits and extracted different rules and patterns that could handle an architectural violation inside the MVVM architectural pattern for Android Applications. Rules could be implemented in any IDE that supports mobile development oriented to Android, like, for example, Visual Studio Code or Sublime Text (despite its constraints).


\section{UAST in Android Studio}
The Android Studio Integrated Development Environment (IDE) is widely used for mobile development and the creation of Android applications. Within its ecosystem, it provides various built-in libraries, frameworks, and programs that support the development process and improve performance in terms of architectural standards and non-functional requirements. Among these tools are mechanisms designed to prevent the introduction of poor implementation practices according to specific architectural guidelines. One such mechanism is the linter. A linter is an IDE-integrated tool that identifies potential issues in the source code and, when possible, suggests corrective actions. When a developer introduces a code fragment that violates recommended practices, Android Studio highlights the issue within the interface. The developer can then inspect the warning, which includes the rule name, a description, a justification for the alert, and in some cases, a proposed solution.
The linter in Android Studio works by leveraging the Unified Abstract Syntax Tree (UAST) generated for each project. UAST is a structured representation created for the source code opened within the IDE and includes both the Abstract Syntax Tree (AST) and the call graph of the application. With this representation, it is possible to implement semantic components—similar to the visitor structures described in previous definitions—that analyze project files to detect patterns in code fragments. The structure exposes elements defined by the Kotlin programming language grammar, including class declarations and other code constructs, and allows access to metadata such as names, file locations, package identifiers, and component relationships. Using these structures and attributes, developers may define custom lint check rules capable of detecting patterns and suggesting corrective actions.
Following the model of the default lint rules included in Android Studio, custom lint checks can be created for detecting architectural violations based on insights obtained from the analyzed GitHub commits of open-source Android projects.

\begin{figure}[h]
    	\centering
    		\includegraphics[scale=0.25]{./figures/uast_structure.png}
   			 \caption{Definition of Android Studio UAST structure \citet{} }
   			 \label{fig:ast}
\end{figure}

Inside the UAST structure in Android Studio, we can easily implement visitors of the abstract syntax tree. With that representation of the structure of the source code of an Android project, we can instantiate each one of them to analyze it in terms of patterns in its name, its structure, its declaration, and other features that could indicate an architectural erosion issue implemented in its structure.

\section{Rules Definition}
With the representative set extracted from the architectural erosion issues identification process, it is possible to analyze code fragments where the two judges confirmed that it could be a possible architectural violation of the original GitHub source code repository. With that, GitHub commits set and the Google architectural guidelines based on the MVVM architectural pattern \citet{google-architecture}, it is possible to find troubles in architectural changes. With these architectural erosion issues, we can infer different patterns in terms of class naming, method invocation, dependency injection, and other features that could mainly affect the application performance and other significant architectural requirements inside an Android project. In the table $table_rules$, we present the different found rule sets implemented in the Kotlin programming language, whose implementation could indicate an architectural erosion issue inside an Android project.


\begin{table}[H]
\begin{adjustwidth}{-4cm}{-4cm}
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        ID & Rule & Scope & Description \\
        \hline
        1 & Error Handling Issue & Warning & \makecell{This rule consists of bad error handling in try-catch statements. \\ Statements like only logging methods or stacktrace println \\ are considered as bad implementations} \\
        \hline
        2. & Blocking Operations Use Issue & Warning & \makecell{There are some blocking methods \\ of the main thread of an Android application. \\ Functions like blockingGet could affect the normal performance \\ of  the main thread of an Android application} \\
        \hline
        3 & View Model Error Handler Issue & Warning & \makecell{Similar to rule 1. It detects bad error handling in \\ stream clauses from live data in the viewmodel layer, \\ based on the MVVM architectural style} \\
        \hline
        4 & Bad HTTP client Implementation Issue & Warning & \makecell{ Detection of bad HTTP client implementations. \\ Incomplete configuration that affects latency \\  and the application performance} \\
        \hline
        5 & High Coupling Rate Issue & Warning & \makecell{This rule generates an alert when it finds \\ the most coupled class with another class and components} \\
        \hline
        6 & \makecell{ Class Declaration in \\ View Model Scope Function Issue} & Warning & \makecell{ No use of component instances, \\ only new class declarations in \\ view model function scopes.} \\
        \hline
         \end{tabular}
    \caption{Features of commits dataset and their description}
    \label{tab:my_label}
\end{adjustwidth}
\end{table}




\section{AER Detection Component Implementation}
To implement the architectural-erosion detection rules for Android applications written in Kotlin, we use the lint API provided by the Android Studio IDE and must understand how to integrate its functionality into a project, including version compatibility for libraries and build tools such as the Gradle plugin. First, create an empty Android project and then add a module that will host the custom lint checks. Add the lint API libraries to that module to enable the linter’s functionality. For each architectural-erosion rule, declare an Issue object that defines the rule’s attributes (name, description, category, scope, and severity). Each Issue must be associated with a visitor component that acts as the detector; the visitor is configured to inspect the specific AST/UAST constructs relevant to the rule. For example, to detect poor error-handling implementations, the visitor should examine try–catch constructs by leveraging UAST types such as UTryCatchStatement and applying filters on names and code-block structure. After implementing the Issue objects and their visitors, register the rules in a custom LintRegistry and package the implementation as an Android library. The generated JAR can then be included in the application via the Gradle configuration so the custom rules are available to the IDE. Optionally, an XML descriptor can be used to enumerate and name each custom lint rule. Finally, with the AER rules implemented and the build environment configured, run the lint analysis from the console (for example, invoking the lint functionality with the command maven --lint args) to execute both the default and the custom lint checks declared in the AER component.


\section{AER Detection Component Testing Criteria}
Once we have the AER component with all the implemented architectural erosion rules and the parameters configuration for compatibility of each Android application, we select specific criteria for testing the implemented custom lint check rules based on the analyzed open source applications and their commit set. With the hash commit attribute, we can select a specific instant of that implementation inside the Android project source code repository and observe the custom lint check rules' effectiveness. Due to the different versions of all library ecosystems in Android development, we need to configure the test apps to set as environment variables the Java version compatibility and the Gradle plugin compatibility of the AER plugin. With these observations, we need to select specific test apps and set the environment variables for a correct lint process of each test application. Furthermore, we selected another similar tools that act as a linter in the Android Studio IDE. We will compare the effectiveness of the AER issues detection component with:


\begin{itemize}
	\item SonarLint: SonarLint is the SonarQube plugin for the Android Studio IDE. SonarQube is a platform based ins static code analysis. This platform detects code smells, security issues, and connectivity issues (in some specific cases). SonarQube is one of the most used code analysis platforms in the software development industry \cite{sonarlint}.
	\item Detekt: Detekt is a default linter for Android apps and the Kotlin programming language. This plugin detects some code smells for specific Kotlin files or packages of an Android app. This plugin is one of the most used for mobile development, in the code analysis stage \cite{detekt}.
	\item Android Studio default linter: The Android Studio IDE contains an integrated code inspection tool. In that tool, we can define and specify the standard lint rules to analyze inside an Android app. The tool contains connectivity issues, security vulnerabilities, and code smells related to the Kotlin and Java programming languages.
\end{itemize}

\subsection{Test Apps Selection}
With the detection process previously made, we define a set of three applications where different AER issues were detected with the linter model. The selected applications are:

\begin{itemize}
	\item AER anti-pattern application: Once the AER issues were identified, we classified specific AER issues per quality attribute category. With this, we consider building an Android application that includes the identified architectural smells. This is to observe the detection accuracy of the AER detection component. As a secondary objective, we will show the performance in terms of AER issues detection of the AER detection component compared to other lint components for the Android Studio IDE.
	\item Loudius: Loudies is one of the applications analyzed in the AER issues identification stage. Loudious is an open-source Android application consisting of a sample application with architectural guidelines in each layer based on Google's recommended architecture. Loudius is shown as an example of OAuth verification implementation, Jetpack Compose implementation in the UI layer, and the integration with some external components.
	\item Loudius (different commit): The last selected Android app is the same as the second one. However, this Loudius version was selected from a different GitHub commit. In that commit, we identified some AER issues. This application was selected to measure the effectiveness of the linter component and the other lint applications for AER issues detection.
\end{itemize}

Those applications were selected by their component structure for observation of the lint detection behavior and the ease of compatibility with the Java JDK version in which the AER detection component was built. With another analyzed application, they do not have the complete injected components available. In addition, some applications are very difficult to implement Gradle configurations for compatibility with the AER issues detection component.
