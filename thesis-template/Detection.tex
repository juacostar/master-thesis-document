\chapter{Identifying AER With Static Code Analysis techniques}
\label{cha:detection}

With a set of possible causes presented in Kotlin source code files from various Android projects, it is possible to define a set of rules using the Android Studio IDE tools ecosystem for detecting Architectural Erosion issues. We detected architectural changes in the representative set of commits and extracted different rules and patterns that could handle an architectural violation inside the MVVM architectural pattern for Android Applications. Rules could be implemented in any IDE that supports mobile development oriented to Android, like, for example, Visual Studio Code or Sublime Text (despite its constraints).


\section{UAST in Android Studio}
The Android Studio Integrated Development Environment (IDE) is primarily used for mobile development and building Android applications. Inside its ecosystem, there are a lot of built libraries, frameworks, and other programs that make the development process easier and get better performance in terms of the different non-functional requirements and architectural standards. In addition to those programs, other tools avoid committing any bad practice implementation in terms of different standards based on a specific architectural style. This tool is named linter. A linter is an integrated tool with an IDE for code insight detection and correction  (if it is possible). When we write code in Android Studio with bad code practices, its interface shows and marks a possible insight into our code. After that, we select that marker and give a possible solution for that code insight. Every rule shows its name, its description, a possible reason for the insight, and an optional code implementation solution.

This linter implementation, integrated with the Android Studio IDE, is due to the UAST structure generated by that tool. The Unified Abstract Syntax Tree (UAST) is a defined structure generated by each software project opened by the IDE that contains the AST and the Call graph structures of the source code files of that project. With this structure, we can create different semantical components (similar to the visitors components mentioned in the definitions section) that detect any pattern in different structures and code fragments inside the source code files. We can instantiate the different structures based on the grammar of the Kotlin programming language since there are clauses for classes and others. Furthermore, we can access the different attributes of each structure, like name, source code file name, or package name, and their relationships with other components. In terms of rules, we can define any customized lint check rule, and with that structure's set of Kotlin programming language and its attributes, it is possible to detect any pattern and offer any solution suggestion.

Based on the standard rules implemented in the Android Studio IDE, we can similarly define custom lint check rules for error detection, drawing on the insights reviewed from the representative set of commits in open-source Android projects. 

\begin{figure}[h]
    	\centering
    		\includegraphics[scale=0.25]{/Users/juancamiloacosta/Documents/uniandes/tesis 2/thesis template repo/master-thesis-document/thesis-template/figures/uast_structure.png}
   			 \caption{Definition of Android Studio UAST structure \citet{} }
   			 \label{fig:ast}
\end{figure}

Inside the UAST structure in Android Studio, we can easily implement visitors of the abstract syntax tree. With that representation of the structure of the source code of an Android project, we can instantiate each one of them to analyze it in terms of patterns in its name, its structure, its declaration, and other features that could indicate an architectural erosion issue implemented in its structure.

\section{Rules Definition}
With the representative set extracted from the architectural erosion issues identification process, it is possible to analyze code fragments where the two judges confirmed that it could be a possible architectural violation of the original GitHub source code repository. With that, GitHub commits set and the Google architectural guidelines based on the MVVM architectural pattern \citet{}, it is possible to find troubles in architectural changes. With these architectural erosion issues, we can infer different patterns in terms of class naming, method invocation, dependency injection, and other features that could mainly affect the application performance and other significant architectural requirements inside an Android project. In the table $table_rules$, we present the different found rule sets implemented in the Kotlin programming language, whose implementation could indicate an architectural erosion issue inside an Android project.


\begin{table}[H]
\begin{adjustwidth}{-4cm}{-4cm}
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        ID & Rule & Scope & Description \\
        \hline
        1 & Error Handling Issue & Warning & \makecell{This rule consists of bad error handling in try-catch statements. \\ Statements like only logging methods or stacktrace println \\ are considered as bad implementations} \\
        \hline
        2. & Blocking Operations Use Issue & Warning & \makecell{There are some blocking methods \\ of the main thread of an Android application. \\ Functions like blockingGet could affect the normal performance \\ of  the main thread of an Android application} \\
        \hline
        3 & View Model Error Handler Issue & Warning & \makecell{Similar to rule 1. It detects bad error handling in \\ stream clauses from live data in the viewmodel layer, \\ based on the MVVM architectural style} \\
        \hline
        4 & Bad HTTP client Implementation Issue & Warning & \makecell{ Detection of bad HTTP client implementations. \\ Incomplete configuration that affects latency \\  and the application performance} \\
        \hline
        5 & High Coupling Rate Issue & Warning & \makecell{This rule generates an alert when it finds \\ the most coupled class with another class and components} \\
        \hline
        6 & \makecell{ Class Declaration in \\ View Model Scope Function Issue} & Warning & \makecell{ No use of component instances, \\ only new class declarations in \\ view model function scopes.} \\
        \hline
         \end{tabular}
    \caption{Features of commits dataset and their description}
    \label{tab:my_label}
\end{adjustwidth}
\end{table}




\section{AER Detection Component Implementation}
To implement the mentioned architectural erosion detection rules for Android applications implemented in the Kotlin programming language, we need to use the lint API toolset given by the Android Studio IDE. It is necessary to understand the tool and how we can implement its functionalities inside any Android project, in terms of version compatibility of different implemented libraries versions, and automatic dependencies injection tool versions, like the Gradle plugin. 

Firstly, we need to create an empty Android project. After that, we create a module that will be the main component for the custom lint check rules. We inject the main libraries to implement the linter's functionality into the project, in this case, the lint API libraries. When the project base has been implemented, we need to declare each one as an issue for the linter. Each architectural erosion rule must be implemented by stating an issue object, where we define the architectural erosion rule issue and its main attributes like name, description, category (in terms of static analysis tools like lint rules, scope rules, and other ones) severity (if the rule could indicate a severity issue, a warning issue, or another category). When we declare the issue object for each rule, we need to add a visitor component that acts as a detector component to each one. To create a visitor component, we need to inject the structures that we should analyze in each pattern of each architectural erosion rule. As an example, for a bad implementation of error handling in different components and layers of an Android application, we need to analyze the try-catch structures. With UAST libraries from Android Studio, we can inject the UTryCatchStatement, which instantiates the try-catch structures found in the Android source code repository. Furthermore, we can add different filters, of which try-catch statements, which we can select by name and code block structure filters.

With the base components of each architectural erosion rule, we can create a custom lint registry template for setting the custom lint check rules inside any Android project. In this file, we create the architectural erosion rules issues based on the previously created issues. After that, we implement that component as an Android library. By this, we need to inject the .jar generated file into the Android application source code; this is possible by making the .jar libraries accepted by the application in the Gradle plugin configuration file.  After that, we need to use an XML file, setting the specific name of every custom lint check rule.

With the architectural erosion rules, component creation, and the Gradle and environment parameter configuration. We execute the analysis by calling the functionality of Maven named lint. With this console command $maven --lint args$, we execute the lint rules since the default implemented lint check rules and the custom lint check rules are declared in the AER component.

\section{AER Detection Component Testing Criteria}
Once we have the AER component with all the implemented architectural erosion rules and the parameters configuration for compatibility of each Android application, we select specific criteria for testing the implemented custom lint check rules based on the analyzed open source applications and their commit set. With the hash commit attribute, we can select a specific instant of that implementation inside the Android project source code repository and observe the custom lint check rules' effectiveness. Due to the different versions of all library ecosystems in Android development, we need to configure the test apps to set as environment variables the Java version compatibility and the Gradle plugin compatibility of the AER plugin. With these observations, we need to select specific test apps and set the environment variables for a correct lint process of each test application.
Furthermore, we selected another similar tools that act as a linter in the Android Studio IDE. We will compare the effectiveness of the AER issues detection component with:

\begin{itemize}
	\item SonarLint: SonarLint is the SonarQube plugin for the Android Studio IDE. SonarQube is a platform based ins static code analysis. This platform detects code smells, security issues, and connectivity issues (in some specific cases). SonarQube is one of the most used code analysis platforms in the software development industry \cite{sonarlint}.
	\item Detekt: Detekt is a default linter for Android apps and the Kotlin programming language. This plugin detects some code smells for specific Kotlin files or packages of an Android app. This plugin is one of the most used for mobile development, in the code analysis stage \cite{detekt}.
	\item Android Studio default linter: The Android Studio IDE contains an integrated code inspection tool. In that tool, we can define and specify the standard lint rules to analyze inside an Android app. The tool contains connectivity issues, security vulnerabilities, and code smells related to the Kotlin and Java programming languages.
\end{itemize}

\subsection{Test Apps Selection}
With the detection process previously made, we define a set of three applications where different AER issues were detected with the linter model. The selected applications are:

\begin{itemize}
	\item AER anti-pattern application: Once the AER issues were identified, we classified specific AER issues per quality attribute category. With this, we consider building an Android application that includes the identified architectural smells. This is to observe the detection accuracy of the AER detection component. As a secondary objective, we will show the performance in terms of AER issues detection of the AER detection component compared to other lint components for the Android Studio IDE.
	\item Loudius: Loudies is one of the applications analyzed in the AER issues identification stage. Loudious is an open-source Android application consisting of a sample application with architectural guidelines in each layer based on Google's recommended architecture. Loudius is shown as an example of OAuth verification implementation, Jetpack Compose implementation in the UI layer, and the integration with some external components.
	\item Loudius (different commit): The last selected Android app is the same as the second one. However, this Loudius version was selected from a different GitHub commit. In that commit, we identified some AER issues. This application was selected to measure the effectiveness of the linter component and the other lint applications for AER issues detection.
\end{itemize}

Those applications were selected by their component structure for observation of the lint detection behavior and the ease of compatibility with the Java JDK version in which the AER detection component was built. With another analyzed application, they do not have the complete injected components available. In addition, some applications are very difficult to implement Gradle configurations for compatibility with the AER issues detection component.
\section{Detectec AER Insights}
