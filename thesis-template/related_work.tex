\chapter{Related Work}
\label{cha:relatedwork}

\section{Research Methodology}
For architectural erosion symptoms, causes, and consequences identification, during the research, it was necessary to realize a series of steps for identification and possible recovery processes. Due to the orientation of the actual architectural erosion solvers for solving them, mostly for Backend and Frontend projects, it is necessary to identify architectural erosion symptoms in Android apps. After that, with human judges, these symptoms have to be confirmed, and, finally, those symptoms will generate architectural rules for detecting them and suggest different recovery ways during the coding stage of a system.

\subsection{Architectural Erosion: An Initial Overview}
The first approach is to define and explain the concept of architectural erosion in software engineering, and to set the relationship between this concept and the mobile development ecosystem. In the first approach, we look for advances in static analysis solution approach in architecture quality gates in Server-Side and Frontend applications \emph{reference paper uniandes}. In this case, we locate the cited related work in this research to search for the initial motivation for solving architectural erosion issues and find quality gates in terms of performance in the Android ecosystem.

The first overview we extracted about the related in \citet{slr-base}. In this paper, we find a Systematic Literature Review (SLR) that defines the definition, reasons, symptoms, consequences, and solution approaches to architectural erosion. In the resume, this approach finds 73 relevant papers about 8 research questions related to the last-mentioned features. From this approach, we can execute the same query in different research papers databases for more current research, due to the publication year of this research (2021), and the time period criteria (between 2006 and 2009) for finding recent research and advances during the last three years. The paper searches relevant papers in 7 research databases and performs a better-performed query, due to the relation between the "architectural erosion" concept in civil engineering and a phenomenon presented in buildings. We present the first set of search queries and their databases:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|}
        \hline
        Query\\
         \hline
             ("software" OR "software system" OR "software engineering") \\
             AND ("architecture" OR "architectural structure" OR "structural") \\
             AND ("erosion" OR "decay" OR "degradation" OR "deterioration"\\
             OR "degeneration") \\
         \hline
    \end{tabular}
    \caption{Executed Query for related work search}
    \label{tab:my_label}
\end{table}

Since those first results, we can extract relevant papers that include new developments and approaches for fixing architectural erosion issues, metrics, tools, and more related work. With this, we identify in each paper three main stages for solving those issues. In the identification stage, we use different identification alternatives through developer messages in versioning systems like GitHub. The identification Stage, where we use Model Driven Development (MDD) and code patterns identification for detecting the identified architectural violation rules. Finally, based on the solution approach (Design approach, quality approach, etc.), we can suggest a proposal for solving the detected architectural violations.
In the first search iteration, we added another filter related to the publication year. We selected the papers whose publication year is between 2021 and 2024, which include in their bibliography the first SLR that uses as a reference research. Despite different troubles with the query, when different databases show papers related to civil engineering or architecture, this is because the architectural erosion definition in that context is another research topic about building degradation. In this first research iteration, we found researches that synthesize different solution approaches and gives an overview from different perspectives, since the process of AER issues identification, metrics that could indicate a possible architectural violation in a software project, like coupling metrics, and the relationship between classes.
We observed that the use of NLP techniques could improve the performance of AER issues identification based on commit message analysis. With the use of pre-trained Word Embedding models trained in a specific context, different AER issues are detected, and a list of potential keywords could be generated as a type of alert of an architectural violation based on the architectural model base.
In the symptoms and causes approach, an analysis of different base applications made in different programming languages was conducted. Different alternatives and methodologies were evaluated to determine the performance in identifying architectural erosion issues, and different solution approaches were proposed.

\section{Architectural Erosion Symptoms Identification}
In the stage of identification, the latest researches give feedback about identified architectural erosion symptoms and their types during different project stages. However, the detected and named symptoms are oriented to Frontend and Backend development. For mobile development oriented to Android technology, specifically made in the Kotlin programming language, it doesn't exist no repository of possible architectural erosion symptoms. The most recent researches use NLP techniques based on GitHub commits. The researchers analyze the main keywords written in GitHub commits that could indicate a bad architectural issue implementation, identifying a possible architectural erosion issue.
With a large amount of data from Git repositories is possible to make an NLP analysis of Github commits and define metrics that identify (from previously selected commits tagged by expert judges in software engineering and software architecture) similar keywords for architectural erosion. The metric's performance could be affected by the word embedding training context. The most recent research that implements that identification methodology uses a Word Embedding model trained with 10 million Stack Overflow posts, a context that uses technical definitions for defining features, bugs, recommendations, and more of different programming languages. With this context, word embeddings could be more powerful and efficient for detecting architectural erosion issues, keywords \citet{warnings-architectural-erosion,so-word-embedding}.
Another approach is similar to the one mentioned previously. However, those approaches are only based on architectural conformance checking. That consists of a set of different statements for a couple of judges who are professionals in software development and software architecture


\section{Metrics that could indicate Architectural Erosion}
Due to recent research, it is possible to determine the difference in metrics between an implemented architecture and an intended architecture, the main reason for the generation of the phenomenon of architectural erosion. In the resume, there are around 60 detected metrics in the software development process and in applications' source code analysis that could affect the maintainability of a software project. Research selected large software projects written in traditional programming languages like Python and Java, and, with a set of judges, selected different source code implementations and past papers that try to describe and identify with similar methodologies. However, those metrics were detected in other development stacks like Frontend development and Backend development, developed with traditional languages and frameworks. However, in the Android development context, the defined metrics could vary according to the mobile software development process for different reasons, like the recommended architectures for Android development and the mobile software development stages. For this reason, with the reviewed data for this research, we need to find different patterns that would indicate an architectural erosion issue and create a relationship between the reliability metrics found in recent research with the architectural erosion issues found in Android applications' source code.
In this research, it was employed different papers were employed that found a set of metrics in different analysis code platforms that use different methodologies, mainly static analysis code techniques. The research consists of a Systematic Literature Review (SLR) that found different studies from different research databases. The study found 43 relevant papers for architectural erosion metrics. Founded metrics are defined with different criteria statements like historical data revision, architectural complexity, architectural dependency coupling analysis, or architecture size analysis. These metrics were found from open-source software development projects to industrial software development projects.
Different measurement strategies established the effectiveness of the collected metrics. These strategies were found from different code analysis tools like SonarQube, CKJM, etc. Most of the detected issues are mapped to non-functional requirements inside a software development project, but most of them are related to maintainability, architectural issues, and customized quality gates determined by architectural deterioration or evolution.

Furthermore, there are different metrics and reasons to handle good programming practices with different architectural standards. Based on the main quality attributes in software architecture, it is possible to determine control metrics that could identify improvements with the suppression of identified AER issues in the source code of an Android application.
In the availability quality attribute, one of the most common problems during the development stage of a software project is the bad implementation of exception handling. Bad exception handling in a software project could affect the complete flow that achieves a functional requirement and could generate catastrophic software failures and the possibility of a crash of an application. Despite this, some tools use custom lint check rules to detect common bad implementations of exception handling in software development. However, the tools spent considerable machine resources, like computer processing time and RAM. \citet{handle-exceptions-reference}

Additionally, the latency and scalability quality attributes have been implemented with asynchronous programming techniques for better performance in the Android operating system. The recommended architecture standards and guidelines give guidance about the inappropriate use of blocking library functions for data or behavior change operations. The use of synchronous programming techniques in any layer based on the MVVM architecture could affect the use of resources of Android devices. For that, it is necessary to implement the use of coroutine techniques and avoid synchronous operations in mobile application development. In the identification of AER issues stage, it will be essential for testing AER rules and detecting blocking functions in Android source implementations \citet{performance-coroutines-reference}.


\section{Giving Architectural Erosion Solutions}
The latest researches give feedback about identified architectural erosion symptoms and their types during different realization project stages. However, the detected and named symptoms are oriented to Frontend and Backend development. For mobile development oriented to Android technology, specifically made in the Kotlin programming language, it doesn't exist no repository of possible architectural erosion symptoms. To get this, we use an artificial intelligence approach for detecting architectural changes, and those changes and their change messages (commits in the git world) are useful for identifying possible symptoms and generating rules to prevent them \citet{aer-metrics-paper}.


\subsection{Static Analysis Code techniques}
Architectural erosion is a general phenomenon that occurs in all fields of the software development process. Recent research for architectural erosion identification and identification has been focused on Backend development and Frontend development. For this, different static analysis tools have been created as plugins of different Integrated Development Environments. IDEs. One example of this is the use of Antlr-determined grammars in the Eclipse plugin for identifying bad patterns in Data Transaction Object (DTO) files. Those files on Backed development are used for service exposition and communication with other components inside a software project.
There are similar components that use static analysis code techniques in the industry. The most common platforms are SonarQube and different linters with custom lint rules.

With static analysis code techniques, different advantages exist for architectural erosion issue identification. One of them is the ease of detecting patterns in terms of dependency classes, coupling components, class name standards, and package name standards. Furthermore, we can extend that identification approach to detect customized architectural rules for a specific software development process. \citet{master-thesis-aer-backend}

However, in the Android software development context, no platform considers the architectural erosion identification and the identification process with architectural erosion metrics or customized quality gates. For this reason, it is necessary to define an identification process to detect different parents in different components. The pattern identification process must be based on a specific standard or a specific recommended architectural pattern for Android application development. With the main concepts of programming languages, it is possible to define custom lint check rules with different tools like linters and IDE plugins. Static analysis code technique could help mobile developers to find architectural violations to define non-functional requirements in the development stage.


\subsection{NLP techniques and AI Models}
For the architectural erosion identification process (and identification, but mainly the AER identification process), different tools could be useful for architectural violation identification through Natural Language processing fundamentals. As an additional feature to that field, it is possible to use different AI models powered by different training and contextualization techniques to get a better performance in the AER issues identification process. Furthermore, the models present different alternatives to generate corrected code according to the detected issue in the AI training stage.

In research by Li \citet{warnings-architectural-erosion}, the identification methodology is based on the use of pre-trained Word Embedding models. Word Embedding models are essential for building machine learning models based on the transformer architecture. Before that, word embedding models were implemented in different models. According to the two types of word embedding (static and dynamic Word Embedding models), it is useful for specific use cases. This research implements known models based on static Word Embedding models like Glove \citet{glove}, trained by a large corpus of text from different websites.


For the AER identification process, different AI model sets have been implemented for the AER identification process based on developers' messages extracted from a code versioning platform like GitHub, GitLab, or OpenStack. After a large identification process based on human judgments. With this identified AER issues dataset, basic AI models have been proven for potential key identification that could indicate architectural violations. 


Basic models like decision trees, multilayer perceptrons, and other classification models like Gaussian and Naive Bayes machine learning models are used for reliability software measurement. With a defined set of metrics that define the coupling rate between components of any software application, or metrics that define the dependency rate, inheritance depth (in the object-oriented programming paradigm), and cohesion rate. With those metrics, the different AI models were trained for code smell identification concerning software reliability quality attributes. The dataset consists of a set of software projects with the mentioned metrics. All the mentioned metrics are numerical, an important aspect for the use of the mentioned basic machine learning models \citet{perceptron_model}.

The results of the proposed research showed the correlation of some mentioned metrics, which could be related to basic implementations in specific instances of the development stage of the software project, and the effectiveness of the use of machine learning models for finding patterns related to whether defined metrics of any software project or its implementation over time in different versioning platforms  \citet{perceptron_model}.


Furthermore, different AI models with a large number of parameters and based on the transformer architecture were trained with a large amount of commits from different source code versioning platforms. The extracted commits were from different software applications built with programming languages like Java, C++, and Python. Around three million code lines from those projects were extracted for training this model. 
One of the AI models is CodeBERT. CodeBERT is an autoencoder model for multitasking purposes: 

\begin{itemize}
	\item Generate code with better performance compared to an input code fragment.
	\item Explain possible errors and issues in a given code. Those explanations are provided in natural language (English in this case due to its training process).
	\item Give a score based on the code quality of a given source code fragment.
\end{itemize}

The CodeBERT AI model was trained by more than 3 million lines of code in different programming languages. Based on that model, Microsoft presented a set of models derived from the CodeBERT AI model. The variations with the other models are the learning task, the source code input format, and the architecture of each model. This model could be useful for a training process based on code generation for getting a better performance and code quality concerning AER smells or AER issues.
Another model derived from the CodeBERT model is CodeReviewer. The CodeReviewer AI model was trained for three learning tasks: code quality estimation, code refinement, and review comment generation. This model is based on the Roberta transformer model and was trained with millions of source codes of the most popular programming languages. In the future work section, we will talk about the use of that model for code quality based on AER smells and AER bad implementations.


Another machine learning model trained with other classification and generation tasks is the T5 model. This model was developed by Google and was proposed as one of the first machine learning models for code generation. The model is an autoencoder model for getting a code fragment from a requirement written in natural language and for code generation with better performance compared to a code fragment as data input. A similar model with the generation task is the NL2 model \citet{nl2_model}.

There are other proposed models with more complex architectures and larger amounts of data in terms of source code from software projects and commit messages from different versioning platforms. Those models are tested with different benchmarks and have shown effectiveness for some learning tasks that do not demand a large amount of data (in terms of millions of lines of code). Those mentioned models will be relevant to extend the objective of this research for code classification in terms of different quality attributes to get a better performance in Android apps.

Another useful tool powered by AI and NLP techniques is the use of AI Agents. AI Agents are models that make an easy connection with large language models. AI agents allow request automation to large language models with different quantities of data, optimizing costs and time to resolve different learning problems. This is useful for different development problems like AI chatbots and automated responses generation \citet{AI_agents_reference}.

AI agents, in the case of a code review task, could be useful to make judgments and revisions of code fragments. With a customized prompt and batching techniques with large language models, it is possible to evaluate large amounts of code fragments and measure the effectiveness of different code tagging according to a specific criterion. In the case of AER issues identification, we will use an AI agent to measure the effectiveness of the evaluated AI models


\subsection{Metrics Analysis to detect AER Issues}
Comparing metrics over time could be considered another identification approach to AER issues. Different metrics of a different set of applications have been compared to detect some issues in applications, according to the user reviews and the metrics over time of each application, like the number of releases per month, releases per year. With the help of NLP techniques, it is possible to detect potential keywords related to different issues. This solution approach has been widely adopted to detect accessibility issues for different types of applications. In social media applications, this approach has been used to detect issues and opinions related to the accessibility of blind people. The same for platforms for different countries, detecting issues related to app internationalization and interface issues.  \citet{accesibility_issues_metrics_tatiana}.

This solution approach could be useful to adapt to AER issues. AER issues identification would be a complex task with user reviews. However, it is possible to explore a combination of metrics and reviews, processed with NLP techniques, and detect possible issues related to the architecture of any application.









