\chapter{Related Work}
\label{cha:relatedwork}

\section{Research Methodology}
For architectural erosion symptoms, causes, and consequences identification, during the research, it was necessary to realize a series of steps for identification and possible recovery processes. Due to the orientation of the actual architectural erosion solvers for solving them, mostly for Backend and Frontend projects, it is necessary to identify architectural erosion symptoms in Android apps. After that, with human judges, these symptoms have to be confirmed, and, finally, those symptoms will generate architectural rules for detecting them and suggest different recovery ways during the coding stage of a system.

\subsection{Architectural Erosion: An Initial Overview}
The first approach is to define and explain the concept of architectural erosion in software engineering, and to set the relationship between this concept and the mobile development ecosystem. In the first approach, we look for advances in static analysis solution approach in architecture quality gates in Server-Side and Frontend applications \emph{reference paper uniandes}. In this case, we locate the cited related work in this research to search for the initial motivation for solving architectural erosion issues and find quality gates in terms of performance in the Android ecosystem.

The first overview we extracted about the related in \citet{slr-base}. In this paper, we find a Systematic Literature Review (SLR) that defines the definition, reasons, symptoms, consequences, and solution approaches to architectural erosion. In the resume, this approach finds 73 relevant papers about 8 research questions related to the last-mentioned features. From this approach, we can execute the same query in different research papers databases for more current research, due to the publication year of this research (2021), and the time period criteria (between 2006 and 2009) for finding recent research and advances during the last three years. The paper searches relevant papers in 7 research databases and performs a better-performed query, due to the relation between the "architectural erosion" concept in civil engineering and a phenomenon presented in buildings. We present the first set of search queries and their databases:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|}
        \hline
        Query\\
         \hline
             ("software" OR "software system" OR "software engineering") \\
             AND ("architecture" OR "architectural structure" OR "structural") \\
             AND ("erosion" OR "decay" OR "degradation" OR "deterioration"\\
             OR "degeneration") \\
         \hline
    \end{tabular}
    \caption{Executed Query for related work search}
    \label{tab:my_label}
\end{table}

Since those initial results, we extracted relevant papers describing new developments and approaches for addressing architectural erosion—covering metrics, tools, and related work. From this literature we identified three primary stages for dealing with these issues. First, the identification stage, which exploits developer artefacts such as commit messages in version-control systems (e.g., GitHub) to surface potential symptoms of erosion. Second, the detection stage, which applies techniques such as Model-Driven Development (MDD) and pattern-based code analysis to verify and locate concrete architectural-rule violations in the source code. Finally, the remediation stage, in which, depending on the chosen solution strategy (design changes, quality-improvement measures, etc.), we propose concrete fixes for the detected violations. In our first search iteration we added a temporal filter and retained papers published between 2021 and 2024; these works frequently cite earlier systematic literature reviews as foundational references. During the search we encountered irrelevant results from civil engineering and building-architecture domains—an expected artifact because “architectural erosion” is also used in those fields to denote physical degradation. From the selected software-engineering papers we synthesized various solution approaches and produced overviews from multiple perspectives, including processes for AER identification and metrics that may indicate architectural violations (for example, coupling metrics and class-relationship measures). We observed that NLP techniques can improve the identification of AER symptoms when applied to commit-message analysis. Using pre-trained word-embedding models adapted to the software engineering context, it is possible to detect candidate AER issues and generate keyword-based alerts linked to the underlying architectural model. In the symptoms-and-causes line of research, studies that analysed baseline applications implemented in different programming languages evaluated alternative methodologies for detecting architectural erosion and proposed a range of remediation strategies.


\section{Architectural Erosion Symptoms Identification}
Recent research reports identified architectural-erosion symptoms and their types across different project stages. However, these identified symptoms mainly pertain to frontend and backend development. For mobile development—specifically Android apps implemented in Kotlin—no comprehensive repository of possible architectural-erosion symptoms currently exists. Recent studies apply NLP techniques to GitHub commit messages: researchers analyze the keywords found in commits that may indicate poor architectural implementation, thereby surfacing potential architectural-erosion issues. With large volumes of data from Git repositories, it is feasible to apply NLP to GitHub commits and define metrics that—based on a set of commits previously labeled by expert judges in software engineering and software architecture—identify similar keywords associated with architectural erosion. The effectiveness of these metrics can be influenced by the training corpus used for word embeddings. For example, one recent study trained word-embedding models on 10 million Stack Overflow posts, a technical corpus containing descriptions of features, bugs, recommendations, and other programming-related content. In this context, word embeddings may be more effective at detecting architectural-erosion–related keywords \citet{warnings-architectural-erosion,so-word-embedding}. Another related approach relies mainly on architectural conformance checking, which evaluates a set of rules or statements through assessment by a pair of expert judges in software development and software architecture.

\section{Metrics that could indicate Architectural Erosion}
Recent research has made it possible to quantify differences between an implemented architecture and its intended architecture—differences that often lead to architectural erosion. In summary, approximately 60 metrics have been identified throughout the software development process and in source code analysis that may affect the maintainability of a software project. Previous studies examined large-scale projects written in traditional programming languages such as Python and Java, where expert judges analyzed various implementations and compared them with findings reported in earlier studies. However, these metrics were primarily detected in frontend and backend development environments using conventional programming languages and frameworks. In the context of Android development, the applicable metrics may differ due to the particularities of mobile development, such as recommended architectural guidelines and the specific stages of mobile software evolution. Therefore, based on the reviewed literature, it is necessary to identify patterns that indicate architectural erosion within Android applications and establish relationships between reliability metrics found in prior research and erosion issues detected in Android source code. This research draws on multiple studies that identified metrics using diverse source code analysis platforms, most of which rely on static analysis techniques. Conducted as a Systematic Literature Review (SLR), the study collected findings from various research databases and identified 43 relevant papers on architectural erosion metrics. These metrics were categorized according to criteria such as historical revision analysis, architectural complexity, dependency and coupling analysis, and architecture size assessments. The identified metrics were found in both open-source and industrial software projects. Different measurement strategies were used to evaluate the effectiveness of these metrics, employing tools such as SonarQube, CKJM, and others. Most of the detected problems map to non-functional requirements in the software development process, particularly related to maintainability, architectural concerns, and customized quality gates associated with architectural degradation or evolution. Moreover, various additional metrics and guidelines exist to promote good programming practices aligned with architectural standards. Considering the main software architecture quality attributes, it is possible to define control metrics capable of identifying improvements associated with resolving architectural erosion issues in Android applications. For example, within the availability quality attribute, one of the most common issues during development is improper exception handling. Poorly implemented exception handling can disrupt complete execution flows associated with functional requirements, potentially causing severe system failures or application crashes. Some tools provide custom lint rules for detecting common anti-patterns in exception handling; however, these tools often demand significant computational resources, including processing power and memory \citet{handle-exceptions-reference}. Similarly, the latency and scalability attributes in Android development are frequently addressed through asynchronous programming techniques to improve system performance. Recommended architectural guidelines warn against the misuse of blocking operations and synchronous functions within the MVVM architecture, as these may negatively impact device resource consumption. Consequently, the use of coroutines and the avoidance of blocking operations are strongly recommended for Android development. In the architectural erosion identification stage, testing detection rules and identifying blocking calls in Android code will be essential \citet{performance-coroutines-reference}.


\section{Giving Architectural Erosion Solutions}
The latest researches give feedback about identified architectural erosion symptoms and their types during different realization project stages. However, the detected and named symptoms are oriented to Frontend and Backend development. For mobile development oriented to Android technology, specifically made in the Kotlin programming language, it doesn't exist no repository of possible architectural erosion symptoms. To get this, we use an artificial intelligence approach for detecting architectural changes, and those changes and their change messages (commits in the git world) are useful for identifying possible symptoms and generating rules to prevent them \citet{aer-metrics-paper}.


\subsection{Static Analysis Code techniques}
Architectural erosion is a widespread phenomenon that affects all areas of the software development lifecycle. Recent research on identifying and managing architectural erosion has been primarily oriented toward Backend and Frontend development. As a result, several static analysis tools have been developed as plugins for different Integrated Development Environments (IDEs). One example is the use of ANTLR-based grammars in Eclipse plugins to detect poor design patterns in Data Transfer Object (DTO) files, which are commonly used in Backend development for service exposure and communication among software components. Similarly, the software industry offers several platforms that apply static code analysis techniques, such as SonarQube and different linters with customized lint rules. Static code analysis provides several advantages for detecting architectural erosion issues, including the ability to identify patterns related to class dependencies, coupling between components, class naming conventions, and package naming conventions. These capabilities can be extended to detect custom architectural rules tailored to a specific development process or technological environment \citet{master-thesis-aer-backend}. However, in the context of Android software development, there are currently no platforms that explicitly incorporate architectural erosion identification using architectural metrics or customized quality gates. Therefore, it is necessary to define a detection process capable of identifying patterns across different components of an Android application. This process must be based on a clearly defined architectural standard or a recommended architectural pattern for Android development. By leveraging core principles of programming languages, it is possible to create custom lint checks through tools such as static analyzers and IDE plugins. Applying static code analysis techniques in the Android development context would enable developers to detect architectural violations during implementation, facilitating the enforcement of non-functional requirements and minimizing architecture degradation at development time.


\subsection{NLP techniques and AI Models}
For the architectural erosion identification process (and identification, but mainly the AER identification process), different tools could be useful for architectural violation identification through Natural Language processing fundamentals. As an additional feature to that field, it is possible to use different AI models powered by different training and contextualization techniques to get a better performance in the AER issues identification process. Furthermore, the models present different alternatives to generate corrected code according to the detected issue in the AI training stage.

The identification methodology is based on the use of pre-trained Word Embedding models \citet{warnings-architectural-erosion}. Word Embedding models are essential for building machine learning models based on the transformer architecture. Before that, word embedding models were implemented in different models. According to the two types of word embedding (static and dynamic Word Embedding models), it is useful for specific use cases. This research implements known models based on static Word Embedding models like Glove \citet{glove}, trained by a large corpus of text from different websites.
For the AER identification process, different AI model sets have been implemented for the AER identification process based on developers' messages extracted from a code versioning platform like GitHub, GitLab, or OpenStack. After a large identification process based on human judgments. With this identified AER issues dataset, basic AI models have been proven for potential key identification that could indicate architectural violations.
Basic models like decision trees, multilayer perceptrons, and other classification models like Gaussian and Naive Bayes machine learning models are used for reliability software measurement. With a defined set of metrics that define the coupling rate between components of any software application, or metrics that define the dependency rate, inheritance depth (in the object-oriented programming paradigm), and cohesion rate. With those metrics, the different AI models were trained for code smell identification concerning software reliability quality attributes. The dataset consists of a set of software projects with the mentioned metrics. All the mentioned metrics are numerical, an important aspect for the use of the mentioned basic machine learning models \citet{perceptron_model}.
The results of the proposed research showed the correlation of some mentioned metrics, which could be related to basic implementations in specific instances of the development stage of the software project, and the effectiveness of the use of machine learning models for finding patterns related to whether defined metrics of any software project or its implementation over time in different versioning platforms \citet{perceptron_model}.
Furthermore, different AI models with a large number of parameters and based on the transformer architecture were trained with a large amount of commits from different source code versioning platforms. The extracted commits were from different software applications built with programming languages like Java, C++, and Python. Around three million code lines from those projects were extracted for training this model. One of the AI models is CodeBERT. CodeBERT is an autoencoder model for multitasking purposes:

\begin{itemize}
	\item Generate code with better performance compared to an input code fragment.
	\item Explain possible errors and issues in a given code. Those explanations are provided in natural language (English in this case due to its training process).
	\item Give a score based on the code quality of a given source code fragment.
\end{itemize}

The CodeBERT AI model was trained by more than 3 million lines of code in different programming languages. Based on that model, Microsoft presented a set of models derived from the CodeBERT AI model. The variations with the other models are the learning task, the source code input format, and the architecture of each model. This model could be useful for a training process based on code generation for getting a better performance and code quality concerning AER smells or AER issues.
Another model derived from the CodeBERT model is CodeReviewer. The CodeReviewer AI model was trained for three learning tasks: code quality estimation, code refinement, and review comment generation. This model is based on the Roberta transformer model and was trained with millions of source codes of the most popular programming languages. In the future work section, we will talk about the use of that model for code quality based on AER smells and AER bad implementations.
Another machine learning model trained with other classification and generation tasks is the T5 model. This model was developed by Google and was proposed as one of the first machine learning models for code generation. The model is an autoencoder model for getting a code fragment from a requirement written in natural language and for code generation with better performance compared to a code fragment as data input. A similar model with the generation task is the NL2 model \citet{nl2_model}.
There are other proposed models with more complex architectures and larger amounts of data in terms of source code from software projects and commit messages from different versioning platforms. Those models are tested with different benchmarks and have shown effectiveness for some learning tasks that do not demand a large amount of data (in terms of millions of lines of code). Those mentioned models will be relevant to extend the objective of this research for code classification in terms of different quality attributes to get a better performance in Android apps.
Another useful tool powered by AI and NLP techniques is the use of AI Agents. AI Agents are models that make an easy connection with large language models. AI agents allow request automation to large language models with different quantities of data, optimizing costs and time to resolve different learning problems. This is useful for different development problems like AI chatbots and automated responses generation \citet{AI_agents_reference}.
AI agents, in the case of a code review task, could be useful to make judgments and revisions of code fragments. With a customized prompt and batching techniques with large language models, it is possible to evaluate large amounts of code fragments and measure the effectiveness of different code tagging according to a specific criterion. In the case of AER issues identification, we will use an AI agent to measure the effectiveness of the evaluated AI models.


\subsection{Metrics Analysis to detect AER Issues}
Comparing metrics over time could be considered another identification approach to AER issues. Different metrics of a different set of applications have been compared to detect some issues in applications, according to the user reviews and the metrics over time of each application, like the number of releases per month, releases per year. With the help of NLP techniques, it is possible to detect potential keywords related to different issues. This solution approach has been widely adopted to detect accessibility issues for different types of applications. In social media applications, this approach has been used to detect issues and opinions related to the accessibility of blind people. The same for platforms for different countries, detecting issues related to app internationalization and interface issues. \citet{accesibility_issues_metrics_tatiana}.
This solution approach could be useful to adapt to AER issues. AER issues identification would be a complex task with user reviews. However, it is possible to explore a combination of metrics and reviews, processed with NLP techniques, and detect possible issues related to the architecture of any application.










