\chapter{Conclusions and Future Work}
\label{cha:conclusions}
We have explored the problem of AER issues with a focus on Android applications. First, we identified the phenomenon and examined the proposed solutions from other areas of software engineering, defining research questions to analyze this problem within the Android context. Afterwards, we implemented and adapted multiple solution approaches for the Android environment. For each approach, we analyzed and compared results according to the experiments discussed in the related work. Finally, we outlined possible extensions of the proposed methodologies for identifying AER issues, including opportunities to examine other software architecture quality attributes and to detect problems present in specific architectural layers (such as the UI layer of an Android application). With this work, we can present a conclusion aligned with the main objective of the research and the initial research questions.

\section{Research Questions conclusions}

\begin{itemize}
	\item  \textbf{How can we identify Architectural Erosion in Android apps?} Architectural erosion can be identified in different ways. The most well-known identification methodologies of AER are powered by static code analysis tools and the use of AI models and NLP techniques. With these methodologies, we can identify some issues and architectural violations related to one or more architectural guidelines and standards. For AER issues in Android applications, we can identify them with code analysis of the source code of any Android project. We can identify any issue with custom lint check rules or the evaluation of some AI model with code issues detection as a learning task.
	
	\item  \textbf{What methodologies can we use to detect AER in Android apps?} The research examined two primary methodologies for AER issue identification. The first approach focused on static code analysis. A dataset of GitHub commits from several Android applications was analyzed, and issues were manually tagged by two judges experienced in Android development. From this manual process, a set of recurring patterns was identified based on architectural smells and detected issues. These patterns were then transformed into custom lint check rules integrated into the Android Studio linter. The rules were tested on multiple applications, producing warnings and error reports that demonstrated their ability to detect architectural violations. The second methodology relied on AI models and NLP techniques, using both static and dynamic word embedding models to identify potential keywords within GitHub commit messages that could indicate AER issues in the corresponding code. Multiple embedding models were compared to determine which produced keywords with the highest semantic relevance in the context of AER. Additionally, AI models were fine-tuned specifically for the task of AER issue detection, and their results were evaluated using another set of commits alongside an AI agent to measure accuracy. Overall, both methodologies delivered strong results in Android projects and demonstrated potential to assist in identifying issues related to specific software quality attributes.
	
	\item \textbf{How effective are the proposed methodologies?} The implemented methodologies for AER issues identification were tested in different ways. The methodology based on static code analysis techniques was tested with two applications: one that includes some anti-patterns related to architectural guidelines for Android projects, and another that was part of the selected set of applications used for GitHub commit extraction. In both cases, the custom lint check rules generated reports and warnings in the IDE during development, demonstrating good performance. These results suggest that additional lint rules could be created to perform deeper searches for architectural smells within the large set of explored commits. The effectiveness of the second solution methodology was evaluated by comparing it to other AI model testing approaches, manual tagging, and the use of AI agents. The testing results were promising, showing good performance in manual tagging and opportunities for improvement in the AI agent-based evaluation. Overall, the effectiveness of the solution methodologies for identifying AER issues enables the expansion of this research topic and opens the door to exploring additional methodologies connected to architecture guidelines and various quality attributes.


\end{itemize}

According to the answers to the research questions, it is possible to analyze and compare the results obtained from every solution methodology. We defined a set of results and conclusions according to the testing stage of every methodology. 


\section{Conclusions of explored methodologies}

\subsection{Static Code Analysis techniques}
There are some important results related to the development of custom lint check rules for AER issue identification. The built tool for the research scope showed advantages for AER issues:

\begin{itemize}
	\item Static code analysis is very important to identify patterns of different kinds in terms of any programming language components. We can use this approach to identify any issues or insights related to any specific pattern during the development stage. The use of custom lint check rules could support the validation of different rules and standards of different frameworks.
	\item For Android applications, we can use custom lint check rules to detect customized patterns according to any defined pattern in the design stage during the software development cycle. Based on the tools and solutions mentioned in the related work, we can adapt them to solve customized issues in source code fragments of any Android project.
	\item It is possible to combine different solution approaches to improve the performance of static code analysis techniques. The use of NLP techniques and word similarity metrics could be useful to identify patterns and implement them with custom lint check rules. This approach could be improved with the current tools of AI models and NLP techniques.
	\item Static code analysis must be a very important step in the testing and maintenance stages of the software development cycle. The detection of general and customized lint check rules could improve the code performance and the sustainability of any software project. For Android projects, it could improve the costs of development, testing, and maintenance. Use of static code analysis techniques in Android projects would improve the user experience, detecting different issues and patterns in different layers of the application.
\end{itemize}


\subsection{NLP techniques and AI models}
Current tools of AI and NLP can improve at a high scale for detecting anti-patterns and identifying AER issues. The use of static and dynamic word embedding models, AI models, and AI agents defined a complete tool suite to explore different insights inside the source code fragments of Android projects.

\begin{itemize}
	\item Both static and dynamic word embedding models can be useful for identifying potential keywords in GitHub commits from Android projects. Static word embedding models rely on the training context, and when trained within a software development domain, they can yield more accurate results by uncovering new keywords related to quality attributes in Android applications. To measure similarity, the cosine similarity metric proves effective, as its averaged values can highlight semantically related words within a given context. On the other hand, dynamic word embedding models, often derived from advanced AI architectures, offer an even more powerful approach for detecting new keywords. Their training process allows them to adapt to specific contexts, making them well-suited for both classification tasks and the generation of new data.
	
	\item The use of AI models powered by NLP techniques could improve the detection of different issues with a correct training stage. Furthermore, the fine-tuning of AI models related to the detection of code smells as a learning task could detect in an early stage any architectural smell and identify AER issues.
	
	\item AI agents are useful as judges in the testing stage. AI agents can connect with LLMs at a high rate of processing and accuracy in terms of the detection of issues in any programming language. AI agents could be extended to make a connection with little or simplified models to get good processing and responses with a low rate of consumption of resources.
	
	\item NLP techniques are very important to detect words with a high semantic value related to any specific context. With processes like stemming, lemmatizing, and stop word removal, it is possible to find potential keywords that could represent any issue in any specific context. Since the context of versioning platforms of software like GitHub, to the context of reviews in any marketplace of applications, it is possible to measure the semantic value of any word to detect an issue in any project. Focused on Android projects, the use of AI and NLP could extract issues related to the user experience provided by the application. Current AI models will achieve the quality of code and sustainability of any Android project.

\end{itemize}


We observed prominent results with the implementations of every solution methodology for AER issues identification. With a combination of both methodologies, we can improve the identification process and generate optimal solutions to any identified AER issues in the source code of any Android project. Furthermore, with the mentioned methodologies extensions, we can define a prominent future work with a growth opportunity for the detection of any issues related to general or specific quality attributes. The main objective is to extend not only in the Android development environment, but extend them to the identification of issues of any software project based on different architectural patterns and guidelines, and written with any programming language.


\section{Future Work}
In the extensions section, we defined initial steps to apply the studied methodologies for AER issue identification to detect problems in any quality attribute, specifically usability issues. Using the generated commit dataset, it is possible to train machine learning models to evaluate various metrics related to detecting architectural erosion (AER) issues, particularly in Android application development. Additionally, large language models (LLMs) such as CodeReviewer and CodeT5, which are trained for code issue detection and high-performance code generation, can be adapted to tasks such as instruction-based code generation, providing feedback on input code, and producing optimized versions of the source code \cite{codereviewer, codebert, codet5}. Based on the results obtained from implementing static word embedding models, dynamic word embeddings—integrated into large language models (LLMs) trained for software analysis and generation—may offer improved effectiveness. Models such as CodeReviewer and CodeBERT, which leverage dynamic embeddings, can more accurately identify semantically meaningful keywords in commit messages, especially those associated with architectural erosion (AER) issues in source code. By using these models and their ability to capture contextual semantics, it becomes feasible to generate code that adheres more closely to architectural guidelines and standards. While AI systems are already capable of producing complete software projects, incorporating issue-detection mechanisms could significantly enhance the quality and robustness of the generated software. Today, there are many AI models and trained word embedding models for different training tasks. Using these models can improve the quality of the software development process. It is possible to extend the implemented methodology to learning tasks in Large Language Models (LLMs), such as creating AI agents for keyword detection related to specific quality attributes. This research could help analyze large amounts of data in Android projects to evaluate architecture quality. These solutions could reduce costs in any software project. It is essential to leverage process optimizations at every stage of software development, and the use of AI and NLP could ensure better development quality and adherence to standards and policies for a specific architecture \cite{future_work1, future_work2}.





